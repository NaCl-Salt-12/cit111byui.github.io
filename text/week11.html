<p>SUBQUERY</p>
<p>&nbsp;</p>
<p>A subquery is a query inside another query. The subquery executes first and then the result of that query is used as a value in the mainquery, which then runs. A subquery can be nested inside a WHERE, HAVING, FROM or SELECT clause. They can also be placed inside other statements such as an INSERT statement.</p>
<p>&nbsp;</p>
<p>Subquery in an INSERT statement:</p>
<p>&nbsp;</p>
<p>INSERT INTO product</p>
<p>VALUES (999, "Haro Mountain Madhem - 2020", 2020, 450.00,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SELECT brand_id</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; FROM brand</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; WHERE brand_name = "Haro"),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SELECT category_id</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; FROM category</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; WHERE category_name = "Mountain Bikes"));</p>
<p>&nbsp;</p>
<p>The two subquerys are run first returning the values 2 for brand_id of Haro and the value 6 for the category_id of Montain Bikes. Then with those two values the INSERT runs and a new bike is placed in the product table with the proper brand_id and category_id foreign keys entered.</p>
<p>&nbsp;</p>
<p>Subquery in a WHERE clause</p>
<p>&nbsp;</p>
<p>SELECT product_name, list_price</p>
<p>FROM product</p>
<p>WHERE list_price &gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SELECT AVG(list_price)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; FROM product);</p>
<p>&nbsp;</p>
<p>The subquery runs first which finds the average of all the list prices in the product table. Then from that single value result it becomes the last part of the WHERE clause and only those product names and list prices show up that are above the average of all the bikes&mdash;the value that the subquery returned.</p>
<p>&nbsp;</p>
<p>Subquery in a SELECT clause</p>
<p>&nbsp;</p>
<p>SELECT product_name, list_price,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SELECT SUM(quantity)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM cust_order_item</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE product_id = 20) AS Total_Quantity_Sold</p>
<p>FROM product</p>
<p>WHERE product_id = 20;</p>
<p>&nbsp;</p>
<p>The subquery runs returning all quantities added up of the product with product_id of 20 from all the order items. Then the main query runs using that result as it&rsquo;s 3<sup>rd</sup> column of the result set. It returns one row with the product name, the price and then the total quantity of how many of the product have been sold.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>INDEX</p>
<p>&nbsp;</p>
<p>An index provides a way to retrieve data more quickly from a table based on values in specific columns. The database management system can go directly to a specific row with an index rather than having to go row by row until it is found without an index. Indexes do use extra resources and time when updating or deleting rows with indexes, so don&rsquo;t create an index for a column unless you know you will be searching on that column often. Indexes are automatically created for primary keys and unique keys.</p>
<p>&nbsp;</p>
<p>To create an index:</p>
<p>&nbsp;</p>
<p>CREATE INDEX index_name</p>
<p>ON table_name (column)</p>
<p>&nbsp;</p>
<p>CREATE INDEX bike ON product(product_name);</p>
<p>&nbsp;</p>
<p>This would create an index called bike on product_name.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>VIEW</p>
<p>&nbsp;</p>
<p>A view is a virtual table based on the results from a query from one or more base tables. The view table will always refer back to the base table(s) for the most current data, so it&rsquo;s not a point in time copy and doesn&rsquo;t store any data itself. So it always shows up-to-date data. The data is recreated every time the view is referenced; or in other words, the query used to define it is rerun.</p>
<p>&nbsp;</p>
<p>Views come in handy when you have a complex query that you know you will need again and again so you create view from that query and then you have access to the view table without having to run the query again and again. You can also protect your base tables by having this extra layer of security between the user and the base table(s) because of the views. Because the view only contains selected data and are not permanent, users cannot mess up the data and views are often used in applications where the user only gets access to data through these views. You can also make sure only certain data is access by certain users with views.</p>
<p>&nbsp;</p>
<p>CREATE VIEW view_name AS</p>
<p>SELECT column, &hellip;</p>
<p>FROM table</p>
<p>&nbsp;</p>
<p>CREATE VIEW employees_limited AS</p>
<p>SELECT emp_no, first_name, last_name</p>
<p>FROM employees;</p>
<p>&nbsp;</p>
<p>This creates a view called employees_limited using the three columns from the employees table. If there were other columns like salary or social security number in the employees table then the view limits it to just those three columns.</p>
<p>&nbsp;</p>
<p>Then you can use the view just like you use tables in the FROM clause.</p>
<p>&nbsp;</p>
<p>SELECT emp_no, last_name</p>
<p>FROM employees_limited</p>
<p>WHERE last_name = "Simmel";</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
