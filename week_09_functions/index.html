<!DOCTYPE html>
<html lang='en-us'>

<head>
    <meta charset="UTF-8">
    <title>Functions</title>
    <link href="../css/outline_styles.css" rel="stylesheet">
</head>

<body>
    <main>
        <h1>Functions</h1>
        
        <p>In MySQL, a function is a stored program that returns a value or manipulated text. This allows us to perform manipulations on the data before retrieving or saving it. Functions have a name that you refer to and can also accept one or more parameters that can be passed into the function. </p>
        <h3 class="syntax"><function name>(parameter1, parameter2, ...)</h3>
        <p>
           In this lesson, we will be looking at scalar functions that operate on the individual rows of a table.  Scalar means the function will work on a single entity of data, not a group of data together. So if the function is used with a table with many rows the function will work on each single value or entity of data in each row.
        
        <h2>Types of Functions:</h2>
        
        <table>
          <tr>
            <td>Text</td>
            <td>used to manipulate strings of text</td>
          </tr>
          <tr>
            <td>Numeric</td>
            <td>used to perform mathematical operations on numeric data</td>
          </tr>
          <tr>
            <td>Date & Time</td>
            <td>used to manipulate data and time values and to extract specific components</td>
          </tr>
          <tr>
            <td>System</td>
            <td>returns information specific to the DBMS being used</td>
          </tr>
        </table>
        
        
        <p>
            We will be going over some of the more common text, numeric, and date & time functions. 
        </p>
        <h2>Commonly used Text-manipulation or String Functions</h2>
        
        <table>
          <tr>
            <th>Function</td>
            <th>Description</td>
          </tr>
          <tr>
            <td>CONCAT(string, string)</td>
            <td>Returns all the string combined into one string</td>
          </tr>
          <tr>
            <td>LEFT(string, length)</td>
            <td>Returns characters from the left of the string</td>
          </tr>
          <tr>
            <td>RIGHT(string, length)</td>
            <td>Returns characters from the right of the string</td>
          </tr>
          <tr>
            <td>LTRIM(string)</td>
            <td>Trims white space from the left of the string</td>
          </tr>
          <tr>
            <td>RTRIM(string)(string, string)</td>
            <td>Trims white space from the right of the string</td>
          </tr>
          <tr>
            <td>TRIM( string)</td>
            <td>Trims white space from the left and right of the string</td>
          </tr>
          <tr>
            <td>LENGTH(string) </td>
            <td>Returns the length of characters of the string</td>
          </tr>
          <tr>
            <td>LOWER(string)</td>
            <td>Converts the string to lowercase</td>
          </tr>
          <tr>
            <td>UPPER(string)</td>
            <td>Converts the string to lowercase</td>
          </tr>
          <tr>
            <td>LOCATE(find, search, start)</td>
            <td>Find a substring within the string</td>
          </tr>
          <tr>
            <td>SUBSTRING(string, start, length )</td>
            <td>Return characters from within a string</td>
          </tr>
        </table>
        
        <p>
            Let’s use the key table to demonstrate some of the functions.
        </p>
        <pre>
 SELECT * FROM key
         </pre>
    
    <table class='results'>
            <tr>
                <th>keyword_id</th>
                <th>keyword</th>
            </tr>
            <tr>
                <td>1</td>
                <td>sky</td>
            </tr>
            <tr>
                <td>2</td>
                <td>landscape</td>
            </tr>
            <tr>
                <td>3</td>
                <td>people</td>
            </tr>
            <tr>
                <td>4</td>
                <td>nature</td>
            </tr>
        </table>
       
        <pre>

 SELECT CONCAT(‘The primary key of  ‘, keyword, ‘ is ‘, keyword_id) AS new_string, 
 FROM key
 WHERE keyword_id = 1

            </pre>
    
    <table class='results'>
            <tr>
                <th>new_string</th>
            </tr>
            <tr>
                <td>The primary key of sky is 1</td>
            </tr>
     </table>
        <p>
           The result is made up of string literals inside quotes and column values all combined into one new string.   
        </p>
    
        <pre>

 SELECT  LEFT(keyword, 4), LENGTH(keyword), UPPER(keyword)
 FROM key
 WHERE keyword_id = 2


            </pre>
    <table class='results'>
            <tr>
                <th>LEFT(keyword, 4)</th>
                <th>LENGTH(keyword)</th>
                <th>UPPER(keyword)</th>
            </tr>
            <tr>
                <td>land</td>
                <td>9</td>
                <td>LANDSCAPE</td>
            </tr>
     </table>
        <p>
            The first column takes the string ‘landscape’ and returns 4 characters from the left.<br>
            The second column adds up all the characters in the string ‘landscape’<br>
            The third column converts all the letters in the string ‘landscape’ to upper case.
        </p>
      <p>Index numbering of the characters in the string ‘landscape’</p>
      <table>
        <tr>
            <td>l</td>
            <td>a</td>
            <td>n</td>
            <td>d</td>
            <td>s</td>
            <td>c</td>
            <td>a</td>
            <td>p</td>
            <td>e</td>
        </tr>
        <tr>
            <td>1</td>
            <td>2</td>
            <td>3</td>
            <td>4</td>
            <td>5</td>
            <td>6</td>
            <td>7</td>
            <td>8</td>
            <td>9</td>
        </tr>
      </table>
        <pre>

SELECT LOCATE( ‘and’, keyword), SUBSTRING(keyword, 1, 5), SUBSTRING(keyword, 7)
FROM key
WHERE keyword_id  = 2

            </pre>
    <table class='results'>
            <tr>
                <th>LOCATE(‘and’, keyword)</th>
                <th>SUBSTRING(keyword, 1, 5)</th>
                <th>SUBSTRING(keyword, 7)</th>
            </tr>
            <tr>
                <td>2</td>
                <td>lands</td>
                <td>ape</td>
            </tr>
     </table>
    
    
    
        <p>
            The first column searches for the substring ‘and’ inside of the string ‘landscape’ and returns the index number of where it was found. the 2nd character in is where the ‘a’ in ‘and’ starts.<br>
            The second column starts at the first character and returns all character from there to the fifth character.<br>
            The third column starts at the seventh character and returns the rest of the string from there.
        </p>
        <br><br>
        <h2>Commonly used Numeric Functions</h2>
    <table>
          <tr>
            <th>Function</td>
            <th>Description</td>
          </tr>
          <tr>
            <td>ROUND(number, length)</td>
            <td>Returns the number rounded </td>
          </tr>
          <tr>
            <td>FLOOR(number)</td>
            <td>Returns the next smaller whole number</td>
          </tr>
          <tr>
            <td>CEILING(number)</td>
            <td>Returns the next larger whole number</td>
          </tr>
          <tr>
            <td>ABS(number)</td>
            <td>Returns the absolute value of the number</td>
          </tr>
          <tr>
            <td>SQRT(number)</td>
            <td>Returns the square root of the number</td>
          </tr>
          <tr>
            <td>FORMAT(number, decimals, locale)</td>
            <td>Returns the number is currency format</td>
          </tr>
    </table>
   
        <p>
            Lets use the magazine table to demonstrate some of the numeric functions        
        </p>

        <pre>

 SELECT * FROM magazine

            </pre>
        <table class='results'>
            <tr>
                <th>magKey</th>
                <th>magName</th>
                <th>magPrice</th>
            </tr>
            <tr>
                <td>1</td>
                <td>Fishing in the Mojave</td>
                <td>13.95</td>
            </tr>
            <tr>
                <td>2</td>
                <td>Car Racing Made Easy</td>
                <td>15.45</td>
            </tr>
            <tr>
                <td>3</td>
                <td>Pine Cone Computing</td>
                <td>17.50</td>
            </tr>
            <tr>
                <td>4</td>
                <td>Cooking Like Mad</td>
                <td>18.00</td>
            </tr>
            <tr>
                <td>5</td>
                <td>If Only I Could Sing</td>
                <td>25.00</td>
            </tr>
     </table>

     <pre>

SELECT ROUND(magPrice), ROUND(magPrice, 1)
FROM magazine


            </pre>
        <table class='results'>
            <tr>
                <th>ROUND(magPrice)</th>
                <th>ROUND(magPrice,1)</th>
            </tr>
            <tr>
                <td>14</td>
                <td>14.0</td>
            </tr>
            <tr>
                <td>15</td>
                <td>15.5</td>
            </tr>
            <tr>
                <td>18</td>
                <td>17.5</td>
            </tr>
            <tr>
                <td>18</td>
                <td>18.0</td>
            </tr>
            <tr>
                <td>25</td>
                <td>25.0</td>
            </tr>
        </table>
        <p>
            The first column rounds to the nearest whole number.<br>
            The second column rounds to one decimal place.
        </p>

         <pre>

SELECT magPrice, FLOOR(magPrice), CEILING(magPrice)
FROM magazine

            </pre>
        <table class='results'>
            <tr>
                <th>magPrice</th>
                <th>FLOOR(magPrice)</th>
                <th>CEILING(magPrice)</th>
            </tr>
            <tr>
                <td>14</td>
                <td>14.0</td>
            </tr>
            <tr>
                <td>15</td>
                <td>15.5</td>
            </tr>
            <tr>
                <td>18</td>
                <td>17.5</td>
            </tr>
            <tr>
                <td>18</td>
                <td>18.0</td>
            </tr>
            <tr>
                <td>25</td>
                <td>25.0</td>
            </tr>
        </table>


        <p>
            If we wanted to delete the van Gogh row from our table we would use this DELETE statement.
        </p>
        <pre>

 DELETE FROM artist  
 WHERE lname = 'van Gogh';

            </pre>

        <p>
            Don’t forget to always use a WHERE clause with UPDATE and DELETE otherwise every row in the table will be UPDATED or DELETED. You might need to turn off the Safe Mode in Workbench by going to ‘Preferences’ – ‘SQL Editor’ and uncheck “Safe Updates’ near the bottom of the preferences there. Remember there is no undo button once you run a UPDATE or DELETE statement. 
        </p>
        <p>
            The way we create our database this week, we will not need to use the CREATE command because Workbench does that for us in the forward engineering from our ERD to the database set up. We also should not need to use DROP to delete any of our tables or any of our databases. If we need to delete a table or database from Workbench because we made a mistake or want to start over you can run a DROP statement but be careful not to drop something you don’t mean to. You can also right click the table or database name from your schema list in Workbench and drop them that way.  Be very careful with the DROP command. There is no undo button.
        </p>

        <h1>Referential Integrity and Foreign Key Constraints</h1>
        <p>
            Referential Integrity implies that relationships among data should be enforced. This will guarantee that relationships between rows in two tables will remain synchronized during all updates and deletes. When we create a database from our ERD diagram the foreign keys are by default mandatory (or they are already enforcing the relationships between tables. This is referred to as Foreign Key Constraints. This constraint enforces the referential integrity by guaranteeing that changes cannot be made to data in the primary key table if those changes invalidate the link to data in the foreign key table. 
        </p>
        <p>
            This is important to know because, as we enter data, edit and delete data in our tables, we cannot delete a row of data that has a foreign key associated with the primary key of that row in another table. We also cannot add a row to a table with a foreign key that does not already exist as a primary key of another table. 
        </p>
        <p>
            So if an attempt is made to delete a row in a primary key table or to change a primary key value, the action will fail when the deleted or changed primary key value corresponds to a value in the foreign key of another table. To edit or delete a row in a foreign key, you must first either delete the foreign key data in the foreign key table or change the foreign key data in the foreign key table, which links the foreign key to the different primary key.


        </p>

        
    </main>
</body>

</html>
